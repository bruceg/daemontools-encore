.TH fifo 8
.SH NAME
fifo \- create and read a named pipe while writing to child.
.SH SYNOPSIS
.B fifo
.I file
.I child
.SH DESCRIPTION
.B fifo
prints everything fed to the named pipe
.I file
to standard input
of
.IR child .
.I file
is held open for writing so that other programs
can repeatedly open and close
.IR file .
The pipe to
.I child
is held open
for reading so
.I child
can be restarted if it dies without losing data.

.B fifo
creates
.I file
if
.I file
does not exist.

At startup,
.B fifo
prints a banner message ("fifostart") to
.I child
to ensure it is running before reading from
.IR file .
If your platform
supports the FIONREAD ioctl,
.I fifo
will wait until the banner has been
read before reading from
.IR file .
If
.I child
dies before the banner
is read,
.B fifo
exits. Otherwise
.B fifo
tries to restart
.IR child .
It
never gives up.

.B fifo
normally runs forever.
.SH EXIT CODES
.B fifo
normally exits 0 after SIGTERM and
.I child
stops.

.B fifo
exits 100 for improper usage with a message on standard error.

For any other problems,
.B fifo
exits 111 with a message on standard
error.
.SH SIGNALS
SIGTERM
.Sp
.RS 4
.B fifo
stops reading from
.IR file ,
empties its buffer, and closes the
pipe to
.IR child .
.I child
is expected to continue until it notices the
end of file on its standard input and exit gracefully.
.B fifo
then stops.
.RE

SIGALRM
.Sp
.RS 4
.B fifo
sends SIGALRM to
.IR child .
.RE
.SH BUGS
On platforms that don't support FIONREAD,
.B fifo
will begin reading
from
.I file
as soon as it forks
.IR child .
If
.I child
fails to start,
.B fifo
dies and whatever has been read from
.I file
is lost.

While running, if
.B fifo
dies, any messages it has in its buffer are lost
.SH SEE ALSO
mkfifo(1),
mkfifo(2)
